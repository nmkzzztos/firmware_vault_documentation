"use strict";(self.webpackChunkfirmware_vault_docs=self.webpackChunkfirmware_vault_docs||[]).push([[5573],{3951:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"Backend/wrapperdoku","title":"Wrapper Documentation","description":"The wrappers for the analysis tools are currently stored in the `/jobs/`","source":"@site/docs/Backend/wrapperdoku.md","sourceDirName":"Backend","slug":"/Backend/wrapperdoku","permalink":"/firmware_vault_documentation/docs/Backend/wrapperdoku","draft":false,"unlisted":false,"editUrl":"https://github.com/nmkzzztos/firmware_vault_documentation/tree/main/docs/Backend/wrapperdoku.md","tags":[],"version":"current","frontMatter":{},"sidebar":"gettingStartedSidebar","previous":{"title":"Analysis Engine","permalink":"/firmware_vault_documentation/docs/Backend/introduction"},"next":{"title":"Docusaurus","permalink":"/firmware_vault_documentation/docs/Documentation/docusaurus"}}');var r=n(4848),i=n(8453);const o={},s="Wrapper Documentation",l={},c=[{value:"cve-bin-tool.py",id:"cve-bin-toolpy",level:2},{value:"binwalk.py",id:"binwalkpy",level:2},{value:"Requirements for writing your own analysis wrapper",id:"requirements-for-writing-your-own-analysis-wrapper",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"wrapper-documentation",children:"Wrapper Documentation"})}),"\n",(0,r.jsxs)(t.p,{children:["The wrappers for the analysis tools are currently stored in the ",(0,r.jsx)(t.code,{children:"/jobs/"}),"\ndirectory of the Project"]}),"\n",(0,r.jsx)(t.h2,{id:"cve-bin-toolpy",children:"cve-bin-tool.py"}),"\n",(0,r.jsxs)(t.p,{children:["The cve-bin-tool.py is an example implementation of a wrapper for an analysis\ntool. In this case Intel's ",(0,r.jsx)(t.a,{href:"https://github.com/intel/cve-bin-tool",children:"cve-bin-tool"}),"\nwas used. The analysis binary gets called with the path to analyze and the\noutput gets written to a ",(0,r.jsx)(t.code,{children:"json"})," file. Before the data of the output file\ngets inserted, it is checked whether the data already exists in the database\nor not, so the results are not inserted twice."]}),"\n",(0,r.jsx)(t.h2,{id:"binwalkpy",children:"binwalk.py"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"binwalk.py"})," automates the process of running Binwalk on a given firmware\nimage, extracting relevant information, and storing the results in a\ndatabase. It is just a basic implementation, because running it with the\n",(0,r.jsx)(t.code,{children:"-Mer"})," flags, which is required for deeper analysis, requires additional\nsoftware like ",(0,r.jsx)(t.code,{children:"sasquatch"}),", which we could neither install nor compile.\nTherefore this wrapper is a ",(0,r.jsx)(t.code,{children:"TODO"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"requirements-for-writing-your-own-analysis-wrapper",children:"Requirements for writing your own analysis wrapper"}),"\n",(0,r.jsx)(t.p,{children:"Generally, you can decide yourself how the command with which your wrapper is called looks. You will probably want to define some parameters like filepath, image ID, and potentially the directory for logs (if your tool creates any). When defining a bulk job, the user can then enter the placeholder strings for the parameters, which will be replaced with the actual values during execution."}),"\n",(0,r.jsx)(t.p,{children:"The following parameter placeholders are currently available (all are optional):"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"<image_path>"}),": The path to the image file that should be analyzed."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"<image_id>"}),": The ID by which the image can be identified in the database."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"<logging_path>"}),": If you create permanent files, like logs, your wrapper should place them in this directory."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"So, if a user creates a job in the UI with this command:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"python my_scrapper <image_path> <image_id> <logging_path>\n"})}),"\n",(0,r.jsx)(t.p,{children:"a command that is actually executed could look like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"python my_scrapper /path/to/the/image.bin 123 /dir/where/you/can/place/logs\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In your program, you can then call the analysis tool you're wrapping with the image file path. You'll have to write some code that parses the output of the tool and inserts it into the database. For that, you need to create a new table in the database that should include the ",(0,r.jsx)(t.code,{children:"image_id"})," you get in the arguments and the results. All database interaction is currently handled by ",(0,r.jsx)(t.code,{children:"DBConnector.py"}),". You will have to add the necessary insert functions into it."]}),"\n",(0,r.jsxs)(t.p,{children:["Finally, you need to edit the ",(0,r.jsx)(t.code,{children:"Dockerfile_executor"}),". Copy your newly created wrapper into the working directory. Also, don't forget to add any necessary commands to install/load the analysis tool you are wrapping."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(6540);const r={},i=a.createContext(r);function o(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);