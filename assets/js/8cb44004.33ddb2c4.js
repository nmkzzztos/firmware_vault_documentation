"use strict";(self.webpackChunkfirmware_vault_docs=self.webpackChunkfirmware_vault_docs||[]).push([[6302],{1231:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"Backend/introduction","title":"Analysis Engine","description":"Currently, everything related to the Analysis Engine is located in the jobs directory.","source":"@site/docs/Backend/introduction.md","sourceDirName":"Backend","slug":"/Backend/introduction","permalink":"/firmware_vault_documentation/docs/Backend/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/nmkzzztos/firmware_vault_documentation/tree/main/docs/Backend/introduction.md","tags":[],"version":"current","frontMatter":{},"sidebar":"gettingStartedSidebar","previous":{"title":"Data Explorer","permalink":"/firmware_vault_documentation/docs/Frontend/data-explorer"},"next":{"title":"Wrapper Documentation","permalink":"/firmware_vault_documentation/docs/Backend/wrapperdoku"}}');var i=t(4848),r=t(8453);const o={},a="Analysis Engine",l={},h=[{value:"Wording",id:"wording",level:2},{value:"Overview",id:"overview",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"analysis-engine",children:"Analysis Engine"})}),"\n",(0,i.jsx)(n.p,{children:"Currently, everything related to the Analysis Engine is located in the jobs directory."}),"\n",(0,i.jsx)(n.h2,{id:"wording",children:"Wording"}),"\n",(0,i.jsx)(n.p,{children:"First, I want to explain what I mean when I refer to a job or a task."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Job:"})," This is an analysis that needs to be performed on a range of images."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The analysis to be performed is specified by the command that is used to execute it."}),"\n",(0,i.jsx)(n.li,{children:"The range of images is defined by the SQL statement that will return the DB entries of the images (table products)."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task:"})," This is an analysis that needs to be performed on a single image."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A task belongs to a job (jobs can be split up into multiple tasks)."}),"\n",(0,i.jsx)(n.li,{children:"You'll also notice that we store the execution number with the tasks; this number indicates to which execution of a job the tasks belong (if a job is executed for the first time, the execution number is 1; if the job is executed again the next day, it would be 2, and so on). Since we support jobs that potentially analyze the same image again and again with each execution (reanalyze = true), this helps to identify what the newest results are."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Basically, jobs define an analysis for a range of firmware and are broken up into tasks during execution."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"What I call the analysis engine is loosely responsible for performing analysis jobs on the Firmware store."}),"\n",(0,i.jsx)(n.p,{children:"If the user wants to perform the same security analysis for many firmware images, it would take a long time to do them manually. So the goal of the engine is to automate this process."}),"\n",(0,i.jsx)(n.p,{children:"The engine is mostly made up of three parts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"API: Takes requests from the frontend."}),"\n",(0,i.jsx)(n.li,{children:"Scheduler: Decides when to execute jobs."}),"\n",(0,i.jsx)(n.li,{children:"Executor: Performs the job execution."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All of them are located in the jobs directory."}),"\n",(0,i.jsx)(n.p,{children:"In terms of Docker containers, API and scheduler run in the same container (api_scheduler). In theory, they could be separated into two containers, but that would offer no benefits, and so we decided to combine them to keep the Docker environment cleaner. The executor gets its own container since, in that container, all the analysis tools are run, and separating third-party software from the rest of the system seems logical."}),"\n",(0,i.jsx)(n.h1,{id:"analysis-execution-start-to-finish",children:"Analysis Execution Start to Finish"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"User creates a job using the frontend."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The frontend sends a POST request to the API (container: api_scheduler, port: 5000)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The API confirms that the SQL query selects the correct fields."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The API inserts the job data into the DB."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The API sends a signal (HTTP POST, container: api_scheduler, port: 5001, contents: job_id) to the scheduler.py."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Scheduler:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If a new job is created, it's executed once immediately. This is done regardless if a cron schedule is provided."}),"\n",(0,i.jsx)(n.li,{children:"Scheduler also checks if the job has a cron schedule; if it does, it is also entered into the internal ap_scheduler and is subsequently executed at the appropriate time."}),"\n",(0,i.jsx)(n.li,{children:"Before a job is executed, the scheduler checks if it is still set to active (disabled = 0)."}),"\n",(0,i.jsx)(n.li,{children:"Finally, if the job is ready to be executed, a signal is sent to the executor (HTTP POST, container: executor, port 5002, contents: job_id)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The executor receives the signal in its main thread."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The request is then added into a queue for further handling."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The job splitter thread then removes the job from the queue."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The job splitter pulls the job data from the DB, executes the SQL statement to get the selected images, and creates a task for each image (it also ensures that the images actually have a file path/are downloaded)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the job does not have a schedule, we assume the user wants the output as soon as possible, and the tasks are entered into a priority queue; otherwise, they are entered into the normal queue."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The worker processes (there are as many workers as there are processor cores) pull the tasks from the normal/prio queue."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The worker generates the file path for the output.txt (base_dir/job_<job_id>/execution_<execution_nr>/image_<image_id>/)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'It replaces the placeholders in the command ("<image_path>" is replaced with the actual image path, same for logging_path and image_id).'}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Command is executed, and the contents of stdout and stderr are written to the designated output.txt."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"An entry for the task is inserted into the tasks table in the DB."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"done"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If you need further insights, try to check the code. I made every effort to document what every part does in comments."})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);